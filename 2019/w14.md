[TOC](技术栈选型之路)

本文和文中相关实验是由Michael Farinacci(负载测试)、Nick Gordon (Ruby)、Iain McGinniss (Kotlin)和Kevin Steuer (Go)一起合作完成的。

# 背景介绍
我们团队的任务是为 WeWork 构建下一代的身份认证基础设施。随着最近几年 WeWork以及其兄弟公司业务的可预期增长，这套新系统必须高效、全球分布式、可伸缩并能够进行合理的演进以满足未来公司需求的变化，这十分重要。

基于这些挑战，团队认为花时间去调研对比构建微服务的语言和技术栈是非常必要的。我们有三个可选的语言: Go、Kotlin 和 Ruby。比较的方法是在每一个身份认证系统中构建相同的真实组件。我们选择了token mint服务作为测试组件，它基于OAuth2的基础设施生成诸如 refresh 和 access token 之类的承载 token 。这三种语言在WeWork的其余系统中都已经有一些实际应用，并且基于这些语言的应用都由有经验的工程师编码实现。

在完成这三种语言的token mint服务的实现之后，团队通过以下定性和定量指标对它们进行了比较:

* 定性比较代码的可读性
* 定性比较测试每个实现的单元测试和集成测试的难易程度
* 定性比较每个实现中必需的“样板文件”与表示服务本质的代码
* 定性比较每个技术栈可用工具，如ide、静态分析、调试器、分析器等
* 定量比较每个实现的性能，如RT的百分比和机器资源利用率。

最后，像这样的实验不可能完全是科学的——软件工程受社会学因素的影响不亚于受科学和数学的影响。我们的首要目标是选择一个优秀全面的语言和工具集，使得团队在接下来的五年里能够很舒适的使用它。


# The Token Mint Service

对于这个测试，所选择的服务是 token mint, 它生成三种类型的承载令牌:刷新令牌、访问令牌和“操作”令牌。将 Tokem 生产和验证隔离到自己的服务中，可以帮助隔离对系统安全性至关重要的加密密钥的使用。

此服务生成的refresh和access令牌具有通常的OAuth2语义:refresh Token不会过期，但可以撤消，并用于生成18小时后过期的 access Token。“action” token是非标准的添加;访问令牌在单个外部API调用的上下文中交换为操作令牌。我们将在API网关上使用请求拦截器执行此交换(我们使用Kong)，以帮助降低在行为不端的下游服务中意外或恶意令牌日志记录或过滤相关的风险。

从任何其他系统或客户端的角度来看，生成的token只是url安全的ASCII字符串。然而，它们确实有内部结构。它们是二进制协议缓冲区的Base64编码，其中包含token元数据和数字签名。实验中使用的签名算法是ECDSA，在NIST P-256曲线上。

该服务基于gRPC向身份系统的其他授权组件提供五项操作:

* 为指定的用户生成一个refresh token
* 撤销refresh token
* 给定一个不可撤销的refresh token，生成一个access token
* 给定一个不会过期的access token, 生成一个action token
* 在一个已经提供的token上获取信息

该服务非常简单，只需一个工程师在几周内就可以实现，但是必须代表我们构建的真实系统:

* 该服务必须与数据库进行交互，以存储其生成的token上的信息，并记住哪些refresh token已被撤销。
* 该服务必须处理高并发请求，并且能够扩展和分发以处理数千的QPS
* 作为一个对安全十分敏感的系统，系统的输入和输出都必须验证，并且需要仔细使用密码原语

这种性质的系统主要是I/O操作的，并在网络上执行数据库读写。该系统计算最密集的操作是生成和验证数字签名。对比数字签名的验证，token元数据和协议缓冲区的生成在计算消耗上是微不足道的。

# 负载测试
负载测试的客户端使用Go语言实现，使用从服务定义生成的gRPC客户端。负载测试器模拟了与系统交互的用户群，给出了预期使用模式的合理近似值。

对于一个用户，我们可能期望(平均)每六个月有一个refresh token的请求，每天有一个access token请求，每小时有一个action token请求。将这些假设与模拟人口规模p产生估计的平均负载系统:l(p) = p×2.894×10⁻⁴ QPS,与95%的请求被action token请求。假设用户总数为10万，那么负载测试器每秒将生成大约29个token请求。通过调整模拟的总体大小或并行运行多个负载测试进程(如果需要，在不同的机器上)，可以调整服务上的负载。

负载测试客户端记录了以微秒为单位发出的每个请求的RT，以及发生的任何错误。然后使用这些信息生成请求散点图、直方图和其他统计信息。当服务的平均延迟时间或90%的开始显著上升时，我们就可以知道服务何时开始达到其伸缩性限制—这通常表示某些资源匮乏。


# 负载测试的结果
在大约150万人口的情况下数据库开始产生吞吐量性能限制，我们比较了在100万人口情况下实现的性能。在这个总体大小下，负载测试客户端试图平均每秒生成289.4个请求。最有趣的数据是:
![195b25df3aa09d61a056772b65122165.png](evernotecid://28C7647C-21C1-4155-85DD-9CEB7FCE11A6/appyinxiangcom/9056406/ENResource/p492)

从上表我们可以看到三种技术栈的平均响应时间几乎差不多，差距不到一毫秒。然而，Kotlin语言的实现开始出现更糟的95和99百分位延迟;我们推测，这可能是因为该实现方案使用的网络、协程执行和JDBC查询线程池之间传递数据时涉及到上下文切换。然而这种上下文切换在Go和Ruby实现中都是不必要的。同样明显的是，在这三种实现中，Go处理所提供的负载所需的计算时间最少。Ruby的CPU使用统计数据可能有一点误导人，请求在实际处理之前被拒绝导致产生的错误(约3%的请求)对CPU使用的影响很小。

# 负载测试的结论
尽管我们可能有先入之见，但很明显，这三个技术栈都完全能够实现性能敏感的服务。每个实现都运行于现代的硬件上的一个容器，都能够处理直到2021年我们在 WeWork 中才能看到的人口规模，并且通过优化我们的数据库模型可以处理更多的用户规模。

Ruby实现的版本中计算最密集的部分使用了本地原生代码，这意味着我们几乎不必关注它的解释器的性能影响;影响Ruby实现版本的只是Ruby gRPC实现的质量。Go实现似乎是三种实现中效率最高的，并且在我们增加服务负载时其性能特征最具有可预测性。

这三种实现都可以进一步优化——这些负载测试结果并没有对实现的性能进行分析或改进。从实现的角度来看，Go有一点优势。JVM有最好的分析工具和最多的配置选项来从运行的系统中挤出性能，但是这种优化是脆弱的;最好将这些时间投资于架构级别的性能优化。

总的来说，我们得出了一个比较平庸的结论，即性能更多地与设计方法的选择有关，而不是语言的选择。只要资深的工程师理解各个语言技术栈的细微差别，该系统的实现几乎在任何技术栈中都可以实现良好的性能。

# 我们最后的选择
经过团队的投票，我们最后选择了Go,Kotlin第二，Ruby第三。对于选择Go,团队有一下理由：

* 一个更简单的语言自然能够驱动程序员写成更简单的代码，这将使他们更容易在日常基础上进行检查和维护。我们需要关于工具选择和架构的强有力建议，以确保其可以扩展到更高层次的关注点——如果不注意代码的组成架构，那么总的来说，再简单的代码可能也很难理解。
* 通常Go的开发生命周期更简单——直接在开发机器上运行服务、在容器中运行服务、以及运行服务的集群实例之间没有什么区别。为Go微服务生成的容器非常简洁，因为除了POSIX OS接口外，Go二进制文件基本上没有外部依赖。
* Go的性能比其他语言稍好一点，并且没有太多麻烦。其内置的异步处理机制和相关库似乎使其更适合于我们可能在核心平台组中编写的微服务类型。

选择Go技术栈带有强烈的警告，我们必须在以下方面强制规则或建议:

* 依赖关系管理。go官方一旦完善了模块化管理工具go modules, 我们很可能采用这个方案做方案管理。
* 错误或异常的传递和处理——这是Go语言中出了名的薄弱部分，我们必须为此定义一个可行的方案。
* channel 和 goroutine 的使用-初学者可以将这两者联合起来使用。实际上，它并不比 EcmaScript 中的async/wait 或 ReactiveX 模式要差;这在成软件工程实践中越来越常见。

# 实现细节
下面几节将深入讨论Go、Kotlin、Ruby的实现，并具体讨论每种实现的各种优缺点。

## 评估Kotlin
Kotlin是JetBrains设计的一种静态类型的对象函数式语言，于2011年首次发布。它主要编译为JVM字节码，但对编译本地二进制文件(通过LLVM)和转换为Javascript提供了实验性支持。

我们认为Kotlin比Java的更灵活、更简洁，比Scala也更简单，Kotlin可以作为Java或者是Scala的替代品。它在Android生态系统中迅速流行起来，现在谷歌将Kotlin作为Android应用程序和库的第一语言选择。

### 实现注意事项
在Kotlin的实现中有三个非常重要的因素，它们对最终代码的结构和性能有很大的影响:

* 除了gRPC-java本身引入的类似框架的元素外，我们的代码(Token Mint Service)中应该避免引入框架。我们的服务非常简单，我们感觉Spring Boot、Lagom或Vert之类的框架带来的好处很少，相反这些框架很重，反而会混给实现代码带来复杂性，让我们的工程师对代码产生混淆，特别是对于那些不熟悉Kotlin或JVM的工程师。因此，系统的初始化逻辑和与数据库的交互应该比使用框架要更加直白。
* 函数式编程库Arrow被广泛的应用在促进函数式编程风格，特别是，这两种类型都被广泛使用，而不是使用为错误抛出异常的方式。在方法调用上显式地检查错误，这让代码风格看起来很像Go一样，不过Arrow的monad comprehensions 和 flatMap chaining 的使用相比同等的命令式Go代码来说，其对可读性的破坏要小一些。
* 协程与async/ wait结合使用，试图简化代码的并发和异步部分。

### 优点
Kotlin是一种优秀的全面性语言:在语言特性上它与Ruby的表达能力相匹配，同时保持了强大的静态类型安全性。它的语言特性使得它比Java更紧凑和更富表现力，而不会对于面向对象还是函数式编程更好保持一方面武断。这种语言灵活性特别适合于构建特定领域的抽象，以帮助解决问题。这也是Ruby的核心优势，也可以说是Go的核心弱点.

扩展方法是一个很好的特性，有助于提高代码的可读性。通过使用扩展方法，fluent的编码风格的函数链可以轻松地添加到现有类型中，我们在实现协议缓冲区消息的构造器和验证器时很好地使用了扩展方法。

可以与JVM库、工具和框架的直接相互操作也是一个核心优势:Java程序员可以在几分钟内开始使用Kotlin，即使他们不调整自己的编程风格以适应函数式编程，他们也可以看到有意义的生产力提高。此外Kotlin起源于JetBrains，所以它也拥有一个优秀的IDE。

### 缺点
虽然用Kotlin实现函数式编程非常的灵活、实用，可以作为Kotlin的一种独特的优点，但它也可以被看作是一种缺点:很容易被函数式的代码风格搞得晕头转向，最终导致代码难以阅读。当我们深入的使用Arrow库的时候这种情况就会发生——虽然等效的命令式风格的代码可能更长，但它更容易理解，而且其区别并不大。

作为一种相对较新的语言，它为程序员提供了各种各样的语言工具，目前使用该语言还没有成熟的最佳实践方法论。因此，这将导致跨项目、团队和个人对问题采用截然不同的编码风格和方法。相比之下，Go和Ruby有更多的固定用法。

比较尴尬的是，Kotlin的协程任然处于实验性阶段，并不完善，所以使用起来有很多顾略。特别是，组合协程和Arrow的任意一种类型的理解都是困难的。Arrow的EitherT monad转换器对理解有帮助，但对一个外行人来说，这个可能比较神奇

一些核心Java api已经比较老旧，并且不适合现代的异步编程。JDBC是一个典型的例子:像获取数据库连接和分派查询这样的操作都是阻塞操作。在JDBC的异步后继可用之前，必须通过单独的线程池进行JDBC调用，以避免阻塞协程线程。

## 评估Go
Go是一种静态类型的命令式语言，于2009年由谷歌首次发布。它诞生于谷歌需要解决大规模的软件工程问题，并且通常编译为静态链接的本地二进制文件。

Go一般被看做是C/C++的替代品，它保持了语言的简单性，同时又提供了内置的基本功能，比如垃圾收集和异步编程原语。Go越来越多的被用于工程组织的后端系统，包括Uber、Slack、Dropbox和Twitch。

### 实现注意事项
我们使用Go的grpc框架，利用 go-grpc-middleware 来处理一些公共的基础逻辑，比如处理异常、opentracing和请求参数的校验。这样我们就可以得到一个非常干净的公共服务组件，并且在我们的微服务中可以重用。

对于我们的库，我们使用了带有智能默认值的函数选项模式，灵感来自 Dave Cheney’s blog post 和 gRPC。

### 优点
我们选择Go的原因包括以下几个优点:

* 内置并发模块。channel和goroutine使得并发程序能被轻易写出，并且具有可读性。
* 自动格式化代码，让我们不必讨论编码风格，比如是使用tab还是空格键。
* godoc文档是go tools的一个标准内置功能。

### 缺点
对于go语言的实现版本，遇到的最大问题是使用go-sqlmock进行数据库单元测试。最初SQL语句是为MYSQL风格vs Postgres，直到集成测试运行时才捕获。另一种方法可能是使用基于postgres协议的内存db数据库。

Go中的Errors机制比较简单，错误检查也很单调，而且代表了代码的很大一部分。这导致团队需要提出他们自己的错误类型或策略。

依赖管理工具的混乱导致团队对于选择哪一种管理工具具有困惑。新的依赖管理工具Go modules 最近已经在Go 1.11中发布，所以这个问题可能会得到全面解决。

## 评估Ruby
Ruby是一种动态类型的、面向对象的解释脚本语言。1995年，松本幸弘(Yukihiro Matz)首次发布了这款语言。直到今天，松本幸弘仍然积极参与这款语言的设计。Ruby的解释器是用C和Ruby混合编写的，可以基于包(称为“gems”)做本地原生扩展，如C、c++或Rust。

我们认为Ruby是一种更灵活的动态类型语言，公司在这方面有丰富的经验。WeWork的大多数应用程序(截至2018年6月)都是用Ruby编写的，主要使用Ruby on Rails。

### 实现注意事项
Ruby版本的实现中没有使用框架，但是代码结构的组织类似于Ruby on Rails(模型、控制器、服务等)。由于我们的数据模型的比较简单，我们编写了一个简单的pg gem包装器，而不是使用 activerecord 或其他 DAO/ORM 库。

我们使用 BigCommerce 编写的 gruf 来管理 gRPC 请求。它抽象出管理 GRPC 服务器的大部分中间层的关注点，同时如果需要，仍然公开底层配置。

### 多线程/水平扩展
服务端的处理是完全异步的——从controller到数据库死亡调用，每个请求都在自己的线程中运行。解释器有一个全局锁，因此更复杂的线程在Ruby应用程序代码中并不常用。相对于Ruby，其他语言的实现更容易水平扩展。

Docker映像相对来说明显更大(使用alpine的类似部署镜像仍然是Kotlin或Go容器大小的2.5倍)，但在大多数部署中，这并不是很大的差别，因为只有在初始拉取镜像的时候才需要耗用网络处理时间。

Ruby gRPC 服务端(使用官方库)不适用队列处理请求(因为合并了这个pr)，这意味着在高负载下它将拒绝许多的请求。

### 优点
作为测试套件的一部分，编写了集成测试，这些测试很容易打包为套件的其他实现的验收测试套件。RSpec做了很好的支持，并且易于扩展，但是对于非ruby开发人员来说，代码的可读性带来了很大的障碍。

虽然这个项目中的数据库逻辑足够简单，以至于作者觉得没有必要做任何比基本的Ruby postgres gem更复杂的事情，但是更复杂的数据库项目可以切换到使用 ActiveRecord，并利用ORM来实现Rails的强大功能。

虽然在撰写本文时OpenTracing还没有添加到项目中，但是在NewRelic tracking和monitoring中添加一个简单的Gruf拦截器是必需的。在微调中还添加了额外的工具，并且需要对代码进行最小的更改。

### 缺点
这个项目的大部分消息内容都是围绕字节和加密的。

将uuid作为字节处理并不困难，但它不是第一选择。这需要编写一些helper方法，这些方法编写起来很简单，但是在这样的项目上下文中会增加额外的开销。

Ruby中的密码学通常通过系统库(Ruby NaCl或OpenSSL)来完成，但是这个项目特别指定了Tink。由于Tink不是用Ruby实现的(在本文发布时仅用c++、Java和Go实现)，因此需要多个导入和处理程序来匹配其他实现。

在编写本文时，Ruby生成代码语法中的一个主要痛点已经得到了解决:ruby_package现在可以用来动态地声明名称空间，这使得Ruby代码更加符合习惯(release和gRPC pr)。








